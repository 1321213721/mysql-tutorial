(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{651:function(v,_,t){"use strict";t.r(_);var n=t(15),s=Object(n.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"多版本并发控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多版本并发控制"}},[v._v("#")]),v._v(" 多版本并发控制")]),v._v(" "),t("p",[v._v("MySQL 的大多数事务型存储引擎实现都不是简单的行级锁。为了提升并发性能，一般都同时实现了多版本并发控制（MVCC）。Oracle、PostgreSQL 等也实现了 MVCC，但各自实现机制不同，因为 MVCC 没有一个统一的实现标准。")]),v._v(" "),t("p",[v._v("可以认为 MVCC 是行级锁的变种，但在很多情况下避免了加锁操作，因此开销更低。虽然实现机制不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。")]),v._v(" "),t("p",[v._v("MVCC 的实现，是 "),t("strong",[v._v("通过保存数据在某个时间点的快照来实现的")]),v._v("。也就是说，不管需要执行多长时间，每个事物看到的数据都是一致的。根据事物开始的时间不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。这句话目前笔者就不能完全理解，这个需要熟悉之后，才会理解")]),v._v(" "),t("p",[v._v("前面说到不同存储引擎的 MVCC 实现是不同的，，典型的有乐观锁（optimistic）并发控制和悲观（pessimistic）并发控制")]),v._v(" "),t("p",[v._v("InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。存储的不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事物，系统版本号都会自动递增。事物开始时刻的系统版本号会作为事物的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下再 REPEATTABLE READ 隔离级别下，MVCC 具体是如何操作的")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("SELECT：会根据以下两个条件检查每行记录：")]),v._v(" "),t("ul",[t("li",[v._v("InnoDB 只查找版本早于当前事物版本的数据行（行的系统版本号小于或等于事物的系统版本号），这可以 "),t("strong",[v._v("确保事物读取的行，要么是在事务开始前已经存在的，要么是事物自身插入或则修改过的")]),v._v("。")]),v._v(" "),t("li",[v._v("行的删除版本要么未定义，要么大于当前事物版本号。这可以 "),t("strong",[v._v("确保事物读取到的行，在事物开始之前未被删除")]),v._v("。")])])]),v._v(" "),t("li",[t("p",[v._v("INSERT")]),v._v(" "),t("p",[v._v("InnoDB 为新插入的每一行保存当前系统版本号作为行版本号")])]),v._v(" "),t("li",[t("p",[v._v("DELETE")]),v._v(" "),t("p",[v._v("InnoDB 为删除的每一行保存当前系统版本号作为行删除标识")])]),v._v(" "),t("li",[t("p",[v._v("UPDATE")]),v._v(" "),t("p",[v._v("InnoDB 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识")]),v._v(" "),t("p",[v._v("保存这两个额外的系统版本号，使大多数读操作都可以不同加锁。使得读取数据操作很简单，性能很好，也能保证读取到符合标准的行。不足的是需要额外的存储空间和更多的行检查工作、额外的维护工作")])])]),v._v(" "),t("p",[v._v("MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个级别下工作。其他两个级别不兼容（MVCC 没有正式的规范，由各个存储引擎实现决定），因为 READ UNCOMMITTED 总是读取最新的数据行，而 SERIALIZABLE 则会对所有读取的行都加锁")]),v._v(" "),t("p",[v._v("疑问：笔者这里没有想明白，是否是 MYSQL 的数据行，与  elasticsearch 类似？是不可变的，是通过标记删除旧的数据，让新的数据生效的机制？")])])}),[],!1,null,null,null);_.default=s.exports}}]);