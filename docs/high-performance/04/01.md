# 选择优化的数据类型

MySQL 支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储那种类型的数据，下面几个简单的原则都有助于做出更好的选择。

- 更小的通常更好

  一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为他们占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更好。

  但是要确保没有低估需要存储的值的范围，因为在 schema 中的多个地方增加数据类型的范围是一个非常耗时和痛苦的操作。如果无法确定哪个数据类型是最好的，就选择你认为不会超过范围的最小类型。（如果系统不是很繁忙或则数据量不是很多，修改数据类型也比较容易）

- 简单就好

  简单数据类型的操作通常需要更少的 CPU 周期。

  例如：整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型更复杂。

  如：应该使用 MySQL 内置的日期类型，而不是使用字符串来存储、应该用整型存储 IP 地址。

- 尽量避免 NULL

  很多表都包含可为 NULL 的列，即使应用程序并不需要保存 NULL 也是如此，因为可为 NULL 是列的默认属性。通常情况下最好指定列为 **NOT NULL**，除非真的需要存储 NULL 值

  因为查询中包含可为 NULL 的列，对 MySQL 来说更难优化，因为 **可为 NULL 的列使得索引、索引统计和值比较都更复杂**。在 MySQL 中需要对 **NULL 值的存储** 特殊处理，因此 **会使用更多的存储空间**。当为 NULL 的列被索引时，每个索引记录需要一个外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。

  通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小，所以调优时没有必要首先在现有 schema 中查找并修改掉这种情况，除非确定这会导致问题。但是， **如果计划在列上建索引** ，就应该尽量避免设计成可为 NULL 的列。

  例外的是：InnoDB 使用单独的位（bit）存储 NULL 值，所以对于稀疏数据（大部分数据为 NULL）有很好的空间效率。但这一点不适用于 MyISAM。



本章只讨论基本的数据类型。MySQL 为了兼容性支持很多别名，例如 INTEGER、BOOL 以及 NUMERIC，他们只是别名，不会影响性能。建表时使用别名，然后用 SHOW CREATE TABLE 检查，会发现 MySQL 报告的是基本类型，而不是别名。

## 整数类型

两种类型：整数（whole number）和实数（real number）

| 整数类型  | 使用位空间 | 占用字节 |
| :-------: | :--------: | :------: |
|  TINYINT  |     8      |    1     |
| SMALLINT  |     16     |    2     |
| MEDIUMINT |     24     |    3     |
|    INT    |     32     |    4     |
|  BIGINT   |     64     |    8     |

他们可存储值的范围是  -2^(N-1)^ 到 2^(N-1)^-1，N 是存储空间的位数。

整数类型可选 UNSIGNED 属性，表示不允许负值（无符号整数），正数范围大致提高了一倍。存储空间不变，性能不变。

你的选择决定 MySQL 是怎么在内存和磁盘中保存数据的。然而，整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境也是如此。（一些聚合函数是列外，他们使用 DECIMAL 或 DOUBLE 进行计算）

MySQl 可以为整数类型指定宽度，例如 `INT(11)`，这对大多数应用是没有意义的，它它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具（例如命令行客户端）用来显示字符的个数。对于存储和计算来说，`INT(1)` 和 `INT(20)` 是相同的。

## 实数类型

实数是带有小数部分的数字。它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数 。MySQL 既支持精确类型，也支持不精确类型。

| 列类型  | 存储空间                                 | 是否精确类型 |
| :-----: | ---------------------------------------- | :----------: |
|  fload  | 4 个字节                                 |      否      |
| double  | 8 个字节                                 |      否      |
| decimal | 每 4 个字节存 9 个数字，小数点占一个字节 |      是      |

FLOAT 和 DOUBLE 类型支持使用标准浮点运算进行近似运算（依赖平台的浮点数具体实现），CPU 直接支持原生浮点计算，但是不支持对 DECIMAL 的直接计算，相对而言浮点运算明显更快。

浮点和 DECIMAL 类型都可以指定精度。MySQL 5.0+ DECIMAL 类型允许最多 65 个数字，它只是一种 **存储格式**，在计算中 DECIMAL 会转换为 DOUBLE 类型。

因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用 DECIMAL，例如财务数据。但在数据量比较大的时候，也可以考虑使用 BIGINT 代替，把小数位数去掉，比如 1.05 元，存储为 105 分，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。

## 字符串类型

MySQL 支持多种字符串类型，每种类型还有很多变种，每个字符串列可以自定义自己的字符集和排序规则，这些东西会很大程度上影响性能。

| 类型         | 范围                                                         | 说明                    |
| ------------ | ------------------------------------------------------------ | ----------------------- |
| `Char(M)`    | M=1~255 个字符                                               | 固定长度                |
| `VarChar(M)` | 一行中所有 varchar 类型的列所占用的字节数不能超过 65535 个字节；比如 UTF8mb4 一个字符占用 4 个字节，那么 varchar(10) = 40 字节 | 存储可变长度的 M 个字符 |
| TinyText     | 最大长度 255 个字节                                          | 可变长度                |
| Text         | 最大长度 65535 个字节                                        | 可变长度                |
| MediumText   | 最大长度 16777215 个字节                                     | 可变长度                |
| LongText     | 最大长度 42949667295 个字节                                  | 可变长度                |
| Enum         | 集合最大数目为 65535                                         | 只能插入列表中的值      |

### VARCHAR 和 CHAR 类型

varchar 和 char 是两种最主要的字符串类型。很难精确解释这些值是怎么存储在磁盘和内存中的，因为这跟存储引擎的具体实现有关。

下面的讨论的前提是使用 InnoDB 或 MyISAM 引擎.

存储引擎存储 varchar 和 char 值的方式在内存中和在磁盘上可能不一样，所以 MySQL 服务器从存储引擎读出的值可能需要转换为另一种存储格式。下面是关于两种类型的比较。

#### VARCHAR

用于存储可变长字符串，是最常见的字符串数据类型。需要使用  1  或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节。假设采用 latin1 字符集，一个  `VARCHAR(10)` 列需要 11 个字节的存储空间。`VARCHAR(1000)` 的列则需要 1002 个字节，因为需要  2 个字节存储长度信息。

::: tip

笔者提示：上述讲解的其实是  MySQL 服务器与客户端交互协议里面的解析规则，预计后面可能还会有很多类似协议里面的知识点。

:::

VARCHAR 节省了存储空间，对性能也有帮助。但是，由于行是边长的，在 UPDATE 时可能使行变得比原来更长，这导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。例如：MyISAM 会将行拆成不同的片段存储，InnoDB 则需要分裂页来使行可以放进页内。其他的一些存储引擎也许从不在原书记位置更新数据。

下面这些情况使用 VARCHAR 是合适的：

- 字符串列的最大长度比平均长度大很多
- 列的更新很少，所以碎片不是问题
- 使用了像 UTF-8 这样复杂的字符集，每个字符都使用不同的字节数进行存储。

对于 InnoDB 来说，更灵活，它可以吧过长的 VARCHAR 存储为 BLOB。

#### CHAR

CHAR 类型是定长的，当存储 CHAR 值时，会被自动删除所有的末尾空格，而且会根据需要采用空格进行填充以方便比较。

CHAR 适合存储很短的字符串，或则所有值都接近同一个长度，比如 MD5 值。

对于经常变更的数据，CHAR 也比 VARCHAR 更好，因为定长类型不容易产生碎片。

对于非常短的列，CHAR 比 VARCHAR 在存储空间上也更有效率。（VARCHAR 需要额外字节存储长度）