(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{548:function(s,t,a){s.exports=a.p+"assets/img/image-20200524223336352.a916667a.png"},600:function(s,t,a){"use strict";a.r(t);var e=a(15),r=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"索引案例学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引案例学习"}},[s._v("#")]),s._v(" 索引案例学习")]),s._v(" "),e("p",[s._v("理解索引最好的办法是结合示例，这里准备了一个。")]),s._v(" "),e("p",[s._v("假设要设计一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等等。")]),s._v(" "),e("ul",[e("li",[s._v("必须支持上面这些特征的各种组合来搜索用户")]),s._v(" "),e("li",[s._v("还必须允许根据用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制")])]),s._v(" "),e("p",[s._v("如何设计索引满足上面复杂需求呢？")]),s._v(" "),e("p",[s._v("第一件需要考虑的事情是：需要使用索引来排序，还是先检索数据再排序。"),e("strong",[s._v("使用索引排序会严格限制索引和查询的设计")]),s._v("。例如：希望使用索引根据其他会员对用户的评分排序，则 where 条件中的 "),e("code",[s._v("age between 18 and 25")]),s._v(" 就无法使用索引。如果 MySQL 使用某个索引进行范围查询，也就无法再使用另一个索引（或则是该索引的后续字段）进行排序了。如果这是很常见的 where 条件，那么我们当然就会认为很多查询需要做排序操作（例如文件排序 filesort）")]),s._v(" "),e("h2",{attrs:{id:"支持多种过滤条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#支持多种过滤条件"}},[s._v("#")]),s._v(" 支持多种过滤条件")]),s._v(" "),e("p",[s._v("现在需要看看那些列拥有很多不同的取值，哪些列在 where 子句中出现得最频繁。因为可以让 MySQL 更有效的过滤掉不需要的行。")]),s._v(" "),e("p",[s._v("country 列的选择性通常不高，但可能很多查询都会用到。sex 列的选择性肯定很低，但也会在很多查询中用到。所以考虑到使用的频率，还是建议在创建不同组合索引的时候将 "),e("code",[s._v("(sex,country)")]),s._v(" 列作为前缀。")]),s._v(" "),e("p",[s._v("但是根据传统的经验不建议在选着性低的列上创建索引，这里选择了两个选着性很低的字段作为索引的前缀列，原因有两点：")]),s._v(" "),e("ol",[e("li",[s._v("几乎所有的查询都会用到 sex 列，甚至会把网站设计成每次都只能按某一种性别搜索用户")]),s._v(" "),e("li",[s._v("索引中加上这一列也没有坏处，即使查询没有使用 sex 列，也可以通过下面的诀窍绕过")])]),s._v(" "),e("p",[s._v("诀窍是：如果某个查询不限制性别 ，那么可以通过在查询条件中 "),e("strong",[s._v("新增 "),e("code",[s._v("and sex in('m','f')")]),s._v(" 来让 MySQL 选择该索引")]),s._v("。如果在某些场景中，列有太多不同的值，就会让 in 列表太长，就不适合这种方法。")]),s._v(" "),e("p",[s._v("这个案例显示了一个基本原则："),e("strong",[s._v("考虑表上所有的选项")]),s._v("。当设计索引时，不要只为现有的查询考虑需要哪些索引，还需要考虑对查询进行优化。如果发现某些查询需要创建新索引，但是这个索引又会降低另一些查询的效率，那么应该想一下是否能优化原来的查询。"),e("strong",[s._v("应该同时优化查询和索引找到最佳的平衡")]),s._v("，而不是闭门造车去设计最完美的索引。")]),s._v(" "),e("p",[s._v("接下来，需要考虑其他常见 where 条件的组合，并需要了解哪些组合在没有合适索引的情况下回很慢。"),e("code",[s._v("(sex,country,age)")]),s._v(" 上的索引就是一个很明显的选择，另外很有可能还需要 "),e("code",[s._v("(sex,country,region,age)")]),s._v(" 和 "),e("code",[s._v("(sex,country,region,city,age)")]),s._v(" 这样的组合索引。")]),s._v(" "),e("p",[s._v("这样就会需要大量的索引。如果想尽可能 "),e("strong",[s._v("重用索引")]),s._v(" 而不是建立大量的组合索引，可以使用前面提到的 "),e("code",[s._v("in()")]),s._v(" 技巧来避免同时需要 "),e("code",[s._v("(sex,country,age)")]),s._v(" 和 "),e("code",[s._v("(sex,country,region,age)")]),s._v(" 的索引。如果没有指定这个字段搜索，就需要定义一个全部国家列表，或则国家全部地区列表，来确保索引前缀有同样的约束（组合所有国家、地区、性别将会是一个非常大的条件）。")]),s._v(" "),e("p",[s._v("这些索引将满足大部分最常见的搜索，但是如何为一些生僻的搜索条件（比如 has_pictures、eye_color、hair_color 和 education）来设计索引呢？这些 "),e("strong",[s._v("列的选择性高、使用也不频繁")]),s._v(" 可以选择忽略他们。让 MySQL 多扫描一些额外的行即可。另外一个可选的方法是在 age 列的前面加上这些列，在查询的时候使用 "),e("code",[s._v("in")]),s._v(" 来处理。")]),s._v(" "),e("p",[s._v("你可能已经注意到，我们一直 "),e("strong",[s._v("将 age 列放在索引的最后面")]),s._v("，是因为我们总是尽可能让 MySQL 使用更多的索引列，"),e("strong",[s._v("因为查询只能使用索引的最左前缀")]),s._v("，直到遇到第一个范围条件列。前面提到的列在 where 子句中都是等于条件，但是 age 列多半是范围查询（例如查找年龄在 18~25 岁之间的人）")]),s._v(" "),e("p",[s._v("当然，也可以使用 in 来代替范围查询，例如将条件改写为 "),e("code",[s._v("in(18,19,20,21,22...)")]),s._v("，但不是所有的查询都可以转换。这里描述的基本原则是："),e("strong",[s._v("尽可能将需要做范围查询的列放到索引的后面")]),s._v("，以便优化器能使用尽可能多的索引列。")]),s._v(" "),e("p",[s._v("前面提到可以用 in 的方式覆盖那些不在 where 子句中的列。但是这种技巧不能滥用，否则可能会带来麻烦。因为 "),e("strong",[s._v("每额外增加一个 in() 条件，优化器需要做的组合都将以指数形式增加")]),s._v("，最终可能会极大的降低查询的性能。考虑下面的 where 子句")]),s._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" eye_color  "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'brown'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'blue'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'hazel'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\t"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" hair_color "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'black'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'red'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'blonde'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'brown'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\t"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" sex\t\t\t\t "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'M'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'F'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("优化器则会转化成 "),e("code",[s._v("4x3x2 =24")]),s._v(" 种组合，执行计划需要检查 where 子句中偶有的 24 种组合。对于 MySQL 来说 24 种不是很夸张，但如果组合数达上千则需要特别小心。老版本查询优化需要花很多时间，并消耗大量内存。新版本在组合数超过一定数量后就不再执行计划评估了，这 "),e("strong",[s._v("可能会导致 MySQL 不能很好的利用索引")]),s._v("。")]),s._v(" "),e("h2",{attrs:{id:"避免多个范围条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免多个范围条件"}},[s._v("#")]),s._v(" 避免多个范围条件")]),s._v(" "),e("p",[s._v("假设有一个 last_online 列并希望通过下面的查询显示过期几周上线过的用户")]),s._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" eye_color  "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'brown'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'blue'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'hazel'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\t"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" hair_color "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'black'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'red'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'blonde'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'brown'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\t"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" sex\t\t\t\t "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'M'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'F'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\t"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" last_online "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" date_sub"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("now")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interval")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("7")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("day")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\t"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" age\t\t\t\t "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("between")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("18")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("25")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("p",[s._v("什么是范围条件？从 explain 的输出很难区分 MySQL 是要查询范围值还是查询列表值。explain 使用同样的词 "),e("code",[s._v("range")]),s._v(" 来描述这两种情况。")]),s._v(" "),e("p",[e("img",{attrs:{src:a(548),alt:"image-20200524223336352"}})]),s._v(" "),e("p",[s._v("可以看到从 explain 无法区分这两者的。但是可以从值的范围和多个等于条件来得出不同。在我们看到，第二个查询就是多个等值条件查询。")]),s._v(" "),e("p",[e("strong",[s._v("这两种访问效率是不同的")]),s._v("：")]),s._v(" "),e("ul",[e("li",[s._v("对于范围条件查询：MySQL 无法再使用范围列后面的其他索引列了")]),s._v(" "),e("li",[s._v("对于多个等值条件查询：则没有这个限制")])]),s._v(" "),e("p",[s._v("这个查询有一个问题：它有两个范围条件，last_online 和 age 列。"),e("strong",[s._v("MySQL 可以使用其中一个，但无法同时使用")]),s._v("。")]),s._v(" "),e("p",[s._v("对于上述两个范围查询没有一个直接的办法能够解决，但是可以 "),e("strong",[s._v("将其中一个范围查询转换为简单的等值比较")]),s._v("：last_online 列就是需要 7 天内登陆过的，可以新增一个 active 列，该字段有定时任务来维护，当用户每次登陆时，将对应值设置为 1，并且将过去连续 7 天未登陆的用户值设置为 0。")]),s._v(" "),e("p",[s._v("这个方法可以让 MySQL 使用 "),e("code",[s._v("(active,sex,country,age)")]),s._v(" 索引。active 列并不是完全精确的，但是对于这类查询来说，对精度要求不是那么高。如果需要精确数据，可以把 last_online 列放到 where 子句中，但不加入到索引中。这和前面计算 URL 哈希值来实现 URL 的快速查找类似。")]),s._v(" "),e("p",[s._v("到目前为止，我们可以看到：如果用户希望同时看到活跃和不活跃的用户，可以在查询中使用 "),e("code",[s._v("in()")]),s._v(" 列表。我们已经加入了很多这样的列表，但另外一个可选的方案就只能是为不同的组合列创建单独的索引。只要需要建立如下的索引：")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("(active,sex,country,age)")])]),s._v(" "),e("li",[e("code",[s._v("(active,country,age)")])]),s._v(" "),e("li",[e("code",[s._v("(sex,country,age)")])]),s._v(" "),e("li",[e("code",[s._v("(country,age)")])])]),s._v(" "),e("p",[s._v("这些索引对某个具体的查询来说可能都是更优化的，但是考虑到索引的维护和额外的空间占用的代价，这个可选方案就不是一个好策略了。")]),s._v(" "),e("p",[s._v("在这个案例中，"),e("strong",[s._v("优化器的特性是影响索引策略的一个很重要的因素")]),s._v("。如果未来版本的 MySQL 能够实现松散索引扫描，就能在一个索引上使用多个范围条件，那也就不需要为上面考虑这类查询使用 "),e("code",[s._v("int()")]),s._v(" 列表了。")]),s._v(" "),e("h2",{attrs:{id:"优化排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化排序"}},[s._v("#")]),s._v(" 优化排序")]),s._v(" "),e("p",[s._v("使用文件排序对数据集是很快的，但如果一个查询匹配的结果有上百万行的话会怎样？例如如果 where 子句只有 sex 列，如何排序？")]),s._v(" "),e("p",[s._v("对于 "),e("strong",[s._v("那些选择性非常低的列，可以增加一些特殊的索引来做排序")]),s._v("。例如：可以创建 "),e("code",[s._v("(sex,rating)")]),s._v(" 索引用于下面的查询：")]),s._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("cols"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" profiles "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" sex"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'M'")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("order")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("by")]),s._v(" rating "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("limit")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("这个查询同时使用了 order by 和 limit，如果没有索引的话会很慢。")]),s._v(" "),e("p",[s._v("即使有索引，如果用户界面上需要翻页，并且翻页到比较靠后时查询也可能非常慢。下面这个查询就通过 order by 和 limit 偏移量的组合翻页到很后面的时候")]),s._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("cols"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" profiles "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" sex"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'M'")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("order")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("by")]),s._v(" rating "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("limit")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("100000")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[e("strong",[s._v("无论如何创建索引，这种查询都是个严重的问题")]),s._v("。因为：随着偏移量的增加，MySQL "),e("strong",[s._v("需要花费大量的时间来扫描需要丢弃的数据")]),s._v("。反范式化、预先计算和缓存可能是解决这类查询的 "),e("strong",[s._v("仅有策略")]),s._v("。一个更好的办法是限制用户能够翻页的数量，实际上这对用户体验影响不大，因为很少有用户会在乎搜索结果的第 10 万页。")]),s._v(" "),e("h3",{attrs:{id:"延迟关联"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#延迟关联"}},[s._v("#")]),s._v(" 延迟关联")]),s._v(" "),e("p",[s._v("优化这类索引的另一个比较好的策略是使用 "),e("strong",[s._v("延迟关联")]),s._v("：")]),s._v(" "),e("ol",[e("li",[s._v("通过使用覆盖索引查询返回需要的主键")]),s._v(" "),e("li",[s._v("再跟进这些主键关联原表获得需要的行")])]),s._v(" "),e("p",[s._v("这可以减少 MySQL 扫描那些需要丢弃的行数。下面这个查询显示了如何高效使用 "),e("code",[s._v("(sex,rating)")]),s._v(" 索引进行排序和分页：")]),s._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("cols"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" profiles "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("inner")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("join")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("\n\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("primary")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("key")]),s._v(" cols"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" profiles\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("sex"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'M'")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("order")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("by")]),s._v(" rating "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("limit")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("100000")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("as")]),s._v(" x "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("using")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("primary")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("key")]),s._v(" cols"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- using 和 on 类似，只是使用两个列名相同的进行关联")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("这里的延迟关联为什么能解决减少需要丢弃的行？（前面有一个专门利用 "),e("RouterLink",{attrs:{to:"/high-performance/05/03.html#覆盖索引好处"}},[s._v("覆盖索引使用解延迟关联")]),s._v(" 的小节）。 这里利用了 "),e("strong",[s._v("覆盖索引，不用回表")]),s._v("，性能高了很多，只返回了 10 条数据的 ID，再回表去查询数据。就快了很多了")],1)])}),[],!1,null,null,null);t.default=r.exports}}]);