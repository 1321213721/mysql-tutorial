(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{612:function(t,v,_){"use strict";_.r(v);var a=_(15),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"范式和反范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#范式和反范式"}},[t._v("#")]),t._v(" 范式和反范式")]),t._v(" "),_("p",[t._v("在范式化的数据库中，每个事实数据会出现并且只出现一次，相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。")]),t._v(" "),_("h2",{attrs:{id:"范式的优点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#范式的优点和缺点"}},[t._v("#")]),t._v(" 范式的优点和缺点")]),t._v(" "),_("p",[t._v("当为性能问题而寻求帮助时，经常会被建议对 schema 进行范式化设计，尤其是写秘籍的场景。因为下面这些原因，范式化通常能够带来好处：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("范式化的更新操作通常比反范式化要快")])]),t._v(" "),_("li",[_("p",[t._v("当数据较好的范式化时，只有很少或则没有重复数据，所以值需要修改更少的数据。")])]),t._v(" "),_("li",[_("p",[t._v("范式化的表通常更小，可以更好的放在内存里，所以执行操作会更快")])]),t._v(" "),_("li",[_("p",[t._v("很少有多余的数据意味着检索列表数据时更少需要 DISTINCT 或则 GROUP BY  语句。")]),t._v(" "),_("p",[t._v("比如部门表如果是一张单独的表，则只需要简单的查询这张表就行了。")])])]),t._v(" "),_("p",[t._v("范式化设计的 schema 的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式化的 schema 上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能是一些索引测量无效。")]),t._v(" "),_("p",[t._v("例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。")]),t._v(" "),_("h2",{attrs:{id:"反范式的有点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反范式的有点和缺点"}},[t._v("#")]),t._v(" 反范式的有点和缺点")]),t._v(" "),_("p",[t._v("反范式化的 schema 因为所有数据都在一张表中，可以很好的避免关联。")]),t._v(" "),_("p",[t._v("如果 不需要关联表，则对大部分查询最差的情况则：即使没有使用索引，全表扫描。当数据比内存大时这可能比关联要快得多，因为这样避免了随机 I/O。")]),t._v(" "),_("p",[t._v("单独的表也能使用更有效的索引测量。就是将数据冗余在一张表中，并给他们添加索引，这会更快。")]),t._v(" "),_("h2",{attrs:{id:"混用范式化和反范式化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#混用范式化和反范式化"}},[t._v("#")]),t._v(" 混用范式化和反范式化")]),t._v(" "),_("p",[t._v("范式化和反范式化的 schema 各有优劣，怎么选择最佳的设计？")]),t._v(" "),_("p",[t._v("最常见的反范式化数据的方法是复制或则缓存，在不同的表中存储相同的特定列。在 MySQL 5.+ 版本中，可以使用触发器更新缓存值。")]),t._v(" "),_("p",[t._v("从父表冗余到一些数据到子表的理由是排序的需要。")])])}),[],!1,null,null,null);v.default=s.exports}}]);