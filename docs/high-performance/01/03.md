# 事物

在接触数据库系统的其他高级特性之前，需要先了解事物的概念。

事物是一组原子性的 SQL 查询，或一个独立的工作单元。在事物内的语句，那么全部执行成功，要么全部执行失败。

本节非 MySQL 专属内容。讲解事物的 ACID概念

银行应用是解释事物必要性的一个经典例子。这里简要描述下：用户 Jane 支票账户转移 200 美元到她的储蓄账户，那么至少需要三个步骤

1. 检查支票账户的余额高于 200 美元
2. 从支票账户余额中减去 200 美元
3. 在储蓄账户余额中增加 200 美元

这三个步骤操作必须打包在一个事物中，任何一个步骤失败，则必须回滚所有的步骤。

MySQL 中可以用如下语句来描述上述步骤

```sql
START TRANSACTION;  -- 开始一个事物
SELECT balance FROM checking WHERE customer_id = 123;
UPDATE checking SET balance= = balance - 200.00 WHERE customer_id = 123;
UPDATE savings SET balance= = balance + 200.00 WHERE customer_id = 123;
COMMIT; -- 提交事物
-- 失败时，可使用 ROLLBACK 撤销所有的更改
```

单纯的事物概念并不是故事的全部，如果执行到第 4 条数据时服务器崩溃了，会发生什么？这问题就严重了。

除非系统通过严格的 ACID 测试，否则空谈事物的概念是不够的。ACID 表示：

- 原子性 atomicity

  一个事物必须被视为一个不可分割的最小工作单位，整个事物中的所有操作要么全部提交成功，要么全部失败回滚。

- 一致性 consistency

  数据库总是从一个一致性的状态转换到另外一个一致性的状态。

  在前面的例子中，一致性确保了，即使在执行第 3 条语句时，系统崩溃了，那么两个账户中的数据不会错乱，因为事物最终没有提交

- 隔离性 isolation

  通常来说，一个事物所做的修改在最终提交前，对其他事物是不可见的。

  在前面的例子中，当执行完第 3 条语句时，第 4 条还未开始时，此时有另外一个账户汇总程序开始执行，看到支票账户的余额并没有减去 200 美元。后续讨论隔离离别时，会明白为什么这里说「通常来说」是不可见的

- 持久性 durability

  一旦事物提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

  持久性是个有点模糊的概念，也分很多不同的级别，因为不可能做到 100% 的持久性保证的策略，后续章节会继续讨论这个话题

一个运行良好的事物处理系统，必须具备这些标准特征；

事物的 ACID 特性可以确保银行不会弄丢你的钱。而在应用逻辑中，要实现这一点非常难，甚至说是不可能完成的任务。一个兼容 ACID 的数据库系统，需要做很多复杂单可能用户没有察觉的工作，才能确保 ACID 的实现

像锁粒度升级会增加系统开销一样，事物处理的额外安全性也会导致额外的系统开销。正因为这样，MySQL 的存储引擎架构可以发挥优势的地方。用户可以根据业务是否需要事物处理，来选择合适的存储引擎。

## 隔离级别

隔离性其实比想象的要复杂，在 SQL 标准中定义了 4 种隔离级别，每一种级别都规定了一个事物中所做的修改，哪些事物内和事物间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统开销也更低。

另外，每种存储引擎实现的隔离级别可能都不太一样，这个需要进一步查阅所选存储引擎的手册。下面简单的介绍下 4 种隔离级别：

- READ UNCOMMITTED（未提交读）

  事物中的修改，即使没有提交，对其他事物也都是可见的。事物可以读取未提交的数据，这也被称为 **脏读（Dirty Read）**。

  该级别会导致很多问题，从性能上来说，不会比其他的级别好太多，单缺乏其他级别的很多好处，在实际应用中一般很少使用

- READ COMMITTED（提交读）

  大多数据库默认此级别（但 MySQL 不是）。满足前面提到的隔离性的简单定义：一个事物开始时，只能 「看见」已经提交的事物所做的修改。换句话说，一个事物在提交前所做的操作对其他事物是不可见的。

  有时候也称为 **不可重复读（nonrepeatable）**，因为两次执行同样的查询（单条记录），可能会得到不一样的结果

  这个意思是：A 事物中执行查询，下一个相同的查询还未执行前，B 事物对这部分数据修改了，那么当 A 事物中执行下一条查询语句时，会获取到 B 已提交的数据，导致两次相同查询不一致

- REPEATABLE READ（可重复读）：MySQL 默认事物隔离级别

  解决了 _脏读_ 的问题。保证了同一事物中多次读取相同记录结果是一致的。

  但是理论上可重复读，还是无法解决另一外一个 **幻读（Phantom Read）** 问题：在某个事物中重复读取某个范围内的记录时，另一个事物在该范围内插入了新的记录，导致两次读取不一致的问题，会产生 **幻行（Phantom Row）**。

  InnoDB 和 XtraDB 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。本章后续进一步讨论

- SERIALIZABLE（可串行化）

  最高的隔离级别。通过强制事物串行执行，避免了前面说的幻读的问题。

  简单来说，会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。

  实际情况很少使用该级别，无并发，强一致性时才会考虑该级别。

汇总隔离级别的问题如下：

|     隔离级别     | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :--------------: | :--------: | :--------------: | :--------: | :----: |
| READ UNCOMMITTED |     √      |        √         |     √      |        |
|  READ COMMITTED  |            |        √         |     √      |        |
| REPEATABLE READ  |            |                  |     √      |        |
|   SERIALIZABLE   |            |                  |            |   √    |

## 死锁

