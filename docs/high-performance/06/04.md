# 查询执行的基础

当希望 MySQL 能够以更高的性能运行查询时，最好的办法就是弄清楚 MySQL 是如何优化和执行查询的。一旦理解这一点，很多查询优化工作实际上就是遵循一些原则让优化器能安装预想的合理的方式运行。

换句话说，是时候回头看看前面讨论的内容类：MySQl 执行一个查询的过程。根据下图，我们可以看到当向 MySQL 发送一个轻轻的时候，MySQL 到底做了什么：

![image-20200528212208619](./assets/image-20200528212208619.png)

1. 客户端发送一条查询给服务器
2. 服务器先检查缓存，如果命中了缓存，则立刻返回缓存中的结果。否则进入下一阶段
3. 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。
4. MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询
5. 将结果返回客户端。

## MySQL 客户端/服务器通信协议

一般来说，不需要去理解 MySQL 通信协议的内实现细节，值需要理解通信协议是如何工作的。MySQL 客户端和服务器之间的 **通信协议是「半双工」**的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块独立来发送。

这种协议让 MySQL **通信简单快速**，但是也从很多地方限制了 MySQL。一个明显的限制是：这意味着 **没法进行流量控制**。一旦一端开始发送消息，另一端要接收完整消息才能响应它。这就像来回抛球的游戏：**在任何时刻，只有一个人能控制球，而且只有控制球的人才能将球抛回去（发送消息）**

客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候，参数 **max_allowed_packet ** 就特别重要了（如果查询太大，服务端会拒绝接收更多的数据并抛出相应错误）。一旦客户端发送了请求，它能做的事情就只有等待结果了。

相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送数据。这种情况下，客户端若接收完整的结果，然后取前面几条需要的结果，或则接收完几条后，就粗暴的断开连接，都不是好主意。这也是在必要的时候一定要在查询加上 limit 限制的原因。

换一种方式解释这种行为：当 **客户端从服务器取数据** 时，看起来是一个 **拉数据的过程**，但实际上是 **MySQL 在向客户端推送数据的过程**。客户端不断的接收从服务器推送的数据，客户端也没法让服务器停下来。客户端就像是「从消防水管喝水」

多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是 **获得全部结果集并缓存到内存中**。 MySQL** 通常需要等所有的数据都已经发送给客户端** 才能 **释放这条查询占用的资源**，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放相应的资源。

当使用多数连接 MySQl 的库函数从 MySQL 获取数据时，其结果看起来都像是从 MySQL 服务器获取数据，实际上都是从这个库函数的缓存获取数据。多数情况下着没有问题，但是如果需要返回一个很大的结果集，这样并不好，因为库函数会花很多时间和内存来存储所有的结果集。如果能尽早开始处理这些结果集，就能大大减少内存的消耗，这种情况下可以不使用缓存来记录结果而是直接处理。这样做的缺点就是，对于服务器来说，需要查询完成后才能释放资源，所以在和客户端的交互的整个过程中，服务器的资源都是被整个查询所占用的。

看看使用 php 的时候是什么情况，下面是链接 MySQL 的通常写法

```php
<? php
	$link = mysql_connect(‘localhost’,'user','p4ssword')
  $result = mysql_query('select * from huge_table',$link)
  while($row = mysql_fetch_array($result)){
    // 为结果做点什么
  }
>
```

这代码看起来像只有当你需要的时候，才通过循环从服务器端取出数据。实际上，在调用 `mysql_query()` 的时候，php 就已经将整个结果集缓存到内中。

不同语言处理缓存的方式不同。这里不继续说明

## 查询状态

对于一个 MySQL 链接，或则说一个线程，任何时刻都有一个状态，**该状态表示了 MySQL 当前正在做什么**。有喝多中方式查看当前的状态，最简单的是使用 `show full processlist`(该命令返回结果中的 command 列就表示当前的状态)。在一个查询的生命周期中，状态会变化很多次。MySQL 官方手册中对这些状态值的含义最优权威的解释，下面做一个简单的解释。

- Sleep：线程正在等待客户端发送新的请求

- Query：线程正在执行查询或则正在将结果发送客户端

- Locked：在 MySQL 服务器层，该线程正在等待表锁。

  在存储引擎级别实现的锁，例如 InnoDB 的行锁，并不会体现在线程状态中。对于 MyISAM 来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常会出现。

- Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划

- Copying to tmp table `[on disk]`

  线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做 group by 操作，要么是文件排序操作，或则是 union 操作。如果这个状态后面还有 `on disk` 标记，则表示 MySQL 正在将一个内存临时表放到磁盘上。

- Sorting result：线程正在对结果集进行排序。

- Sending data：这表示多种情况

  - 线程可能在多个状态之间切换
  - 或则在生成结果集
  - 或则在向客户端返回数据

了解这些状态的基本含义非常有用，可以让你很快了解当前「谁在持球」。在一个繁忙的服务器上，可能会看到大量的不正常的状态，例如 statistics 正占用大量的时间。这通常表示，某个地方异常了，可以通过第 3 章的一些技巧来诊断到底是哪个环节出现了问题。

## 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的。 那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个 **对大小写敏感的哈希查找** 实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这情况下查询就会进入下一阶段。

如果当前的查询恰好 **命中了缓存查询**，那么 **在返回查询结果之前**，会 **检查一次用户权限**。这仍然是无须解析查询 SQL 语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL 会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。在第 7 章中的查询缓存一节，你将学习到更多的细节

## 查询优化处理

查询的生命周期下一步是 **将一个 sql 转换成一个执行计划**，MySQL 再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：

- 解析 sql
- 预处理
- 优化 sql 执行计划

这个过程中任何错误（例如语法错误）都可能终止查询。这里不打算详细介绍 MySQL 内部实现，而只是选择性的介绍其中几个独立的部分，在实际执行中，这几部分可能一起执行也可能单独执行。

### 语法解析器和预处理

首先 MySQL 通过关键字将  sql 语句进行解析，并 **生成一颗对应的「解析树」**。MySQL 解析器将使用 MySQL 语法规则验证和解析查询。例如，它将验证是否使用错误的关键字，或则使用关键字的顺序是否正确等，或则验证引号是否能前后正确匹配。

预处理则根据一些 MySQL 规则进一步检查解析树是否合法，例如：这里将检查数据表和数据列是否存在，还会解析名字和别名，看看他们是否有歧义。

下一步预处理会验证权限。这通常很快，除非服务器上有很多的权限配置。

### 查询优化器

选择语法树被认为是合法的了，并且 **由优化器将其转化成执行计划**。一条查询可以有多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。

**MySQL 使用基于成本的优化器**，将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。最初，成本的最小单位是随机读取一个 4k 数据页的成本，后来（成本计算公式）变得更复杂，并且引入了一些 **「因子」**来估算某些操作的代价，如当执行一次 where 条件比较的成本。可以通过查询当前会话的 `Last_query_cost` 的值来得知 MySQL 计算的当前查询的成本。

```sql
select sql_no_cache count(*)
from sakila.film_actor;

show status like 'Last_query_cost';
```

| Variable\_name | Value |
| :--- | :--- |
| Last\_query\_cost | 1040.090000 |

这个结果表示 MySQL 的优化器认为大概需要做 1040 个数据页的随机查找才能完成上面的查询。这是根据一系列的统计信息计算得到的：

- 每个表或则索引的页面个数
- 索引的技术（索引中不同值的数量）
- 索引和数据行的长度
- 索引分布情况

优化器在评估成本的时候并不会考虑任何层面的缓存，他假设读取任何数据都需要一次磁盘 I/O。

有很多中原因会导致 MySQL 优化器选择错误的执行计划，如下所示：

- 统计信息不准确

  MySQL 依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息是准确的，有的偏差可能非常大。例如 ，InnoDB 因为其 MVCC 的架构，并不能维护一个数据表的行数的精确统计信息。

- 执行计划中的成本估算不等同于实际执行的成本

  即使统计信息精准，优化器给出的执行计划也可能不是最优的。例如有时候某个执行计划虽然需要读取更多的页面，但是它的成本却更小。因为如果这些页面都是顺序读或则这些页面都已经在内存中的话，那么它的访问成本很小。MySQL 层面并不知道那些页面在内存中、那些在磁盘上，所以查询实际执行过程中到底需要多少次物理 I/O 是无法得知的。

- MySQL 从不考虑其他并发执行的查询

  这可能会影响到当前查询的速度

- MySQL 也并不是任何时候都基于成本的优化

  有时候也会基于一些固定的规则。例如，如果存在全文搜索的 `match（）` 子句，则存在全文索引的时候就使用全文索引。即使有时候使用别的索引和 where 条件可以更快查询到，MySQL 也任然会使用对应的全文索引。

- MySQL 不会考虑不受其控制的操作成本

  例如执行存储过程或则用户自定义函数的成本

- 优化器有时候无法去估算所有可能的执行

  这一点后面会看到，所以它可能错过时机上最优的执行计划。

MySQL 的查询优化器是非常复杂的部件，它 **使用了很多优化策略来生成一个最优的执行计划**。优化策略可以简单分为两种：

- 静态化	

  可以直接对解析树进行分析，并完成优化。

  例如：优化器可以通过一些简单的代数变换将 where 条件转换成另一种等价形式。静态优化不依赖于特别的数值，如 where 条件中带入的一些常数等。静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生变化。

  **可以认为这是一种「编译时优化」**

- 动态化

  相反，动态优化则和查询的上下文有关，也可能和很多其他因素有关，例如 where 条件中的取值、索引条目对应的数据行数等。这需要在每次查询的时候都重新评估

  **可以认为这是「运行时优化」**

在执行语句和存储过程的时候，动态优化和静态优化的区别非常重要。MySQL 对查询的静态优化只需要做一次，但对查询的动态优化则每次执行都需要重新评估。有时候甚至在查询的执行过程中也会重新优化（例如：在关联操作中，范围检查的执行计划会针对每一行重新评估索引。可以通过 explain 执行计划中的 Extra 列是否有 「range checked for each record」来确认这一点。该执行计划还会增加 select_full_range_join 这个服务器变量的值）。

下面是一些 MySQL 能够处理的优化类型：

- 重新定义关联表的顺序

  数据表的的关联并不总是按照查询中指定的顺序进行。决定关联的顺序是优化器很重要的一部分功能。本章后面将深入介绍这一点。

- 将外连接转化为内连接

  并不是所有的 `outer join` 语句都必须以外连接的方式执行。

  诸多因素，例如 where 条件、库表结构都可能会让外连接等价于一个内连接。MySQL 能够识别这点并重写查询，让其可以调整关联顺序。

- 使用等价变换规则

  MySQL 可以使用一些等价变换来简化并规范表达式。它可以合并和减少一些比较，还可以移除一些恒成立和一些恒不成立的判断。

  例如：`(5=5 and a>5)` 将被改写为 `a>5` 。类似的，如果有 `(a<b and b=c) and a=5`则会改写成 `b>5 and b=c and a=5`。这些规则对于我们编写条件语句很有用，我们将在后续讨论

- 优化 `count()、min（）、maxn()`

  **索引和列是否可为空通常可以帮助 MySQL 优化这类表达式。**

  例如：要找到某一列的最小值，值需要查询对应 B-Tree 索引最左端的记录，MySQL 可以直接获取索引的第一行记录。在优化器生成执行计划的时候就可以利用这一点，在 B-tree 索引中，优化器会将整个表达式作为一个 **常数** 对待。类似的，如果要找一个最大值，也值需要读取 B-Tree 索引的最后一条记录。**如果 MySQL 使用了这种类型的优化，那么在 explain 中就可以看到 「Select tables optimized away」**。 从字面意思可以看出，它表示优化器已经从执行计划中移除了该表，并以一个常数取而代之。

  类似的，没有任何 where 条件的 `count(*)` 查询通常也可以使用存储引擎提供的一些优化（例如：MyISAM 维护了一个变量来存放数据表的行数）

- 预估并转化为常数表达式

  **当 MySQL 检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理**

  例如：一个用户自定义变量在查询中没有发生变化的时候就可以转换为一个常数。数学表达式则是另一种典型的例子。

  **在优化阶段，有时候甚至一个查询也能够转化为一个常数**。一个例子是在索引列上执行 `min()` 函数。甚至是主键或则唯一键查找语句也可以转换为常数表达式。如果 where 子句中使用了该类索引的常数条件，MySQL 可以在查询开始阶段就先查找这些值，这样优化器就能知道并转换为常数表达式。下面是一个例子

  ```sql
  explain
  select film.film_id, film_actor.actor_id
  from sakila.film
           inner join sakila.film_actor using (film_id)
  where film.film_id = 1;
  ```
  | id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
  | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
  | 1 | SIMPLE | film | NULL | const | PRIMARY | PRIMARY | 2 | const | 1 | 100 | Using index |
  | 1 | SIMPLE | film\_actor | NULL | ref | idx\_fk\_film\_id | idx\_fk\_film\_id | 2 | const | 10 | 100 | Using index |

  MySQL 分两步来执行这个查询，也就是上面执行计划的两行输出。

  第一步：先从 film 表找到需要的行。因为在 film_id 字段上有主键索引，所以优化器知道这只会返回一行数据，优化器在生成执行计划的时候，就已经通过索引信息知道将返回多少行数据。因为优化器已经明确知道有多少个值（where 条件中的值）需要做索引查询，所以这里的表访问类型是 const。

  第二步：MySQL 将第一步中返回的 film_id 列当做一个已知值的列来处理。因为优化器清楚在第一步执行完成后，该值就会是明确的了。注意到正如第一步中一样，使用 film_actor 字段对表的访问类型也是 const。

  另一种会看到常数条件的情况是通过等式将常数值从一个表传到另一个表，这可以通过 where、using 或则 on 语句来限制某列取值为常数。在上面的例子中，因为使用了 using 子句，优化器知道这也限制了 film_id 在整个查询过程中都始终是一个常量：因为它必须等于 where 子句中的那个值

- 索引覆盖扫描

  当索引中的列包含所有查询中需要使用的列的时候，MySQL 就可以使用索引返回需要的数据，而无需查询对应的数据行

- 子查询优化

  MySQL 在某些情况下可以将子查询转换为一种效率更高的形式，从而减少多个查询多次对数据进行访问。

- 提前终止查询

  当发现已经满足查询需求的时候，MySQL 总是能立刻终止查询。

  一个典型的例子是当使用了 limit 的子句的时候。初此之外，MySQL 还有几类情况也会提前终止查询，例如：发现了一个不成立的条件，这时 MySQL 可以立刻返回一个空结果。

  当存储引擎需要检索「不同取值」或则判断存在性的时候，MySQL 都可以使用这类优化。例如：我们需要找到没有演员的所有电影

  ```sql
  explain
  select film.film_id
  from sakila.film
           left outer join sakila.film_actor using (film_id)
  where film_actor.film_id is null;
  ```

  | id | select\_type | table | partitions | type | possible\_keys | key | key\_len | ref | rows | filtered | Extra |
  | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
  | 1 | SIMPLE | film | NULL | index | NULL | idx\_fk\_language\_id | 1 | NULL | 1000 | 100 | Using index |
  | 1 | SIMPLE | film\_actor | NULL | ref | idx\_fk\_film\_id | idx\_fk\_film\_id | 2 | sakila.film.film\_id | 5 | 100 | Using where; Not exists; Using index |

  这个查询会过滤所有演员的电影。每一部电影可能会有很多的演员，但是上面的查询一旦找到任何一个，就会停止并立刻判断下一部电影，因为只要有一名演员，那么 where 条件则会过滤掉这类电影。

  类似这种「不同值/不存在」的优化一般可用于 `distinct、not exist()、left join` 类型的查询。

- 等值传播

  如果两个列的值通过等式关联，那么 MySQL 能够把其中一个列的 where 条件传递到另一列上。例如下面的查询

  ```sql
  explain
  select film.film_id
  from sakila.film
           inner join sakila.film_actor using (film_id)
  where film.film_id > 500;
  ```

  因为这里使用了 film_id 字段进行等值关联，MySQL 知道这里的 where 子句不仅适用于 film 表，而且对于 film_actor 表同样适用。如果使用的是其他的数据库管理系统，可能还需要手动通过一些条件来告知优化器这个 where 条件适用于两个表，那么写法如下：

  ```sql
  where film.film_id > 500 and film_actor.film_id > 500;
  ```

  在 MySQL 中这是不必要的，这样写反而会让查询更难维护。

- 列表 `in()` 的比较

  在很多数据库系统中， `in()` 完全等同于多个 OR 条件的子句，因为这两者是完全等价的。在 MySQL 中这点是不成立的，MySQL 将 `in()` 列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个 `o(log n)` 复杂度的操作，等价转换成 or 查询的复杂度为`O(n)`，**对于 `In()` 列表中有大量取值的时候，MySQl 的处理速度将会更快**。

上面的列举只是其中一部分，MySQL 还会做大量的其他优化，即使本章全部用来描述也不够。但上面的例子也已经足够让你明白优化器的复杂性和智能性了。如果从上面这些讨论中我们应该学到什么，那就是 **不要自以为优化器更聪明**。最终你可能会占点偏移，但是更有可能会使查询变得更加复杂而难以维护，而最终的收益却为零。让优化器按照它的方式工作就可以了。

虽然优化器已经很智能了，**但是有时候也无法给出最优的结果**。有时候你可能比优化器更了解数据。

例如：

- 由于应用逻辑使得某些条件总是成立
- 优化器缺少某种功能特性，如哈希索引
- 从优化器执的执行成本角度评估出来的最优执行计划，实际运行中可能比其他的执行计划更慢

如果能确认优化器给出的不是最佳选择，并且清楚背后的原理，那么也可以帮助优化器做进一步的优化。例如，可以在 **查询中添加 hint 提示**，也可以重写查询，或则重写设计更优的库表结构，或则添加更合适的索引。

### 数据和索引的统计信息