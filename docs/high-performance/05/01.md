# 索引基础

如果你想在一本书中找到某个特定的主题，一般会先看书的「索引」，找到对应的页码。

在 MySQL 中，存储引擎用类似的方法使用索引，先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。例如要运行下面的索引

```sql
select first_name from sakila.actor where actor_id = 5;
```

如果  actor_id 列上有索引，则使用该索引找到 actor_id 为 5 的行，然后再返回所有包含该值得数据行。

索引可以包含一个或多个列的值。如果包含多个列，那么 **列的顺序也十分重要**，因为 MySQL **只能高效使用索引的最左前缀的列**。创建一个包含两个列的索引，和创建两个只包含一列的所有是大不相同的，下面将详细介绍。

::: tip 如果使用的是 ORM，是否还需要关心索引？
结论：需要。
因为 ORM 工具做不到很智能，即使是查询优化技术专家也很难兼顾到各种情况，就别说 ORM 工具了。
:::

## 索引的类型

索引有很多种类型，可以为不同的场景提供更好的性能。在 MySQL 中，**索引是存储引擎层实现的**。所以，并没有统一的索引标准，即使多个存储引擎支持同一种类型的所有，其底层的实现也可能不同。

下面来看看 MySQL 支持的索引类型，以及他们的优缺点。

## B-Tree 索引

如果在讨论索引的时候，没有特别指明类型，那么多半说的是 B-Tree 索引，它使用 B-Tree 数据结构来存储数据（每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历）。

大多数 MySQL 引擎都支持这种索引。Archive 引擎不支持，5.1 之前 archive 不支持任何索引，5.1+ 才开始支持单个自增列（AUTO_INCREMENT）的索引。

使用术语「B-Tree」是因为 MySQL 在 CREATE TABLE 和其他语句中也使用该关键字。不过，底层的存储引擎也可能使用不同的存储结构，例如 NDB 集群存储引擎内部实际上使用两天 T-Tree 结构存储这种索引，即使名字是 BTREE；**InnoDB 则使用的是「B+Tree」**，各种数据结构的算法和变种，不在本书讨论范围内。

**存储引擎已不同的方式使用 B-Tree 索引，性能也各有不同，各有优劣**。例如 MyISAM 使用前缀压缩技术使得索引更小，但 InnoDB 则按照原数据格式进行存储。再如 MyISAM 索引通过数据的物理位置引用被索引的行，而  **InnoDB 则根据主键索引应用被索引的行**。

**B-Tree 通常意味着所有的值都是按顺序存储的**，并且每一个叶子页到根的距离相同。下图展示了 B-Tree 索引的抽象表示，大致反映了 InnoDB 索引是如何工作的。MyISAM 使用的结构有所不同，但基本思想是类似的。

![image-20200521140623920](./assets/image-20200521140623920.png)

上图是 B-Tree 结构（从技术上来说是 B+Tree）上的索引

B-Tree 索引加快了访问数据的速度，不再全表扫描来获取需要的数据，而是从索引的根节点（图未画出）开始进行搜索。根节点存放了指向子节点的指针，存储引擎根据这些指针向下查找。通过比较节点页的值和要查找的值可以找到合适的指针进下层子节点，这些指针实际上定义了子节点页中值得上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。

叶子节点比较特别，他们的指针指向的是被索引的数据，而不是其他节点页（不同引擎的「指针」类型不同）。上图仅绘制了一个节点和对应的叶子节点，其实在根节点和叶子节点之间可能有很多层节点页。数的深度和表的大小直接相关。

**B-Tree** 对索引列是顺序组织存储的，所以很 **适合查找范围数据**。例如：在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的，所以像「找出所有以 I 到 K 开头的名字」这样的查找效率会非常高。

假设有如下表数据

```sql
create table People(
	last_name varchar(50)	not null,
    first_name varchar(5)	not null,
    dob	date				not null,
    gender	enum('m','f')	not null,
    key(last_name,first_name,dob)
)
```

对于就的每一行数据，索引中包含了 `last_name,first_name,dob` 列的值。下图显示了该索引是如何组织数据的存储的。

![ ](./assets/image-20200521142110423.png)

索引对多个值进行排序的依据是  `create table` 语句中定义索引时列的顺序。看下最后两个条目，两个人的姓名都一样，则根据他们的出生日期来排列顺序的。

### 有效的查询类型

**B-Tree 索引适用于全键值、键值范围或键前缀查找（最左前缀）**。前面所述的索引对如下类型的查询有效：

- 全值匹配

  和索引中的的所有列进行匹配。例如前面提到的所有可用于查找姓名为 Cuba Allen、出生为 1960-01-01 的人

- 匹配最左前缀

  前面的例子可用于查询所有姓为 Allen 的人，即只使用索引的第一列

- 匹配列前缀

  也可以只匹配某一列的值的开头部分。例如前面的索引可以查找所有以 J 开头的姓的人。这里也只使用了索引的第一列。

- 匹配范围值

  例如前面的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列

- 精确匹配某一列并范围匹配另外一列

  例如前面的索引可用于查找所有姓为 Allen，并且名字是字母 K 开头（比如 Kim、Karl 等）的让你。即第一列 last_name 全匹配，第二列 first_name 范围匹配

- 只访问索引的查询

  B-Tree 通常可以支持「只访问索引的查询」，即只访问索引数据，而不需要访问数据行。后续会继续讨论这种「覆盖索引」的优化。

因为索引树中的节点是有序的，除了按值查找之外，还可以用于查询中的 ORDER BY 操作（按顺序查找）。一般来说，**如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序**。所以，如果 ORDER BY 子句满足前面列出的几种查询类型，则这个所以也可以满足对应的排序需求。

### B-Tree 索引的限制

下面是一些关于 b-Tree 索引的限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引

- 不能跳过索引中的列。

  也就是说，无法用于查找姓为 Smith 并且在某个特定日期出生的人。如果不指定名（first_name），则 MySQL 只能使用索引的第一列

- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

  例如：查询 `where last_name='Smith' and first_name like 'J%' and bob = '1970-12-23'`，这个查询只能使用索引的前两列，因为这里 Like 是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值得数量有限，那么可以通过使用多个等于条件来代替范围条件。



读到这里，你应该明白：**索引列的顺序很重要**